<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>QuickHashMaker – Minimal</title>
	<style>
		:root { color-scheme: dark; }
		body { background:#0b0b0b; color:#e6e6e6; font:14px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; margin:16px; }
		h1 { font-size:18px; text-align:center; margin:0 0 12px; color:#fafafa; }
		.controls { display:flex; flex-wrap:wrap; align-items:center; gap:12px; margin:8px 0 12px; }
		label { display:inline-flex; align-items:center; gap:6px; opacity:.9; }
		button { background:#1f1f1f; color:#e6e6e6; border:1px solid #333; padding:6px 10px; border-radius:6px; cursor:pointer; }
		button:hover { background:#262626; }
		textarea { width:100%; box-sizing:border-box; background:#0f0f0f; color:#e6e6e6; border:1px solid #333; border-radius:6px; padding:8px; tab-size:4; }
		.stats { margin:8px 0; opacity:.9; }
		pre { background:#0f0f0f; border:1px solid #333; border-radius:6px; padding:8px; white-space:pre-wrap; }
		.small { font-size:12px; opacity:.8; }
	</style>
</head>
<body>
	<h1>QuickHashMaker – Minimal</h1>
	<textarea id="editor" rows="18" cols="90" autofocus>enter
one
string
per
line
"or", "many", "on a line", "like this!\r\n"</textarea>
	<div class="controls">
		<button id="startPause" onclick="toggleRun()">Start</button>
		<label><input id="allowMultiplications" type="checkbox" checked />Allow Multiplications</label>
		<label><input id="allowLength" type="checkbox" checked />Allow n</label>
		<label><input id="requireZeroTermination" type="checkbox" checked />Expect Zero Termination</label>
		<label><input id="evalTest" type="checkbox" />Eval-test expression & editor line</label>
		<label><input id="forceEval" type="checkbox" />Use eval engine (if available)</label>
	</div>
	<div class="stats">
		Tested <span id="testedCount">0</span> expressions. Found <span id="solutionsCount">0</span> solutions. Complexity: <span id="complexity">?</span>, table size: <span id="tableSize">?</span>.
		<div id="testStatus" class="small"></div>
	</div>
	<pre id="hashes"></pre>

	<script>
	"use strict";

	// ===== Utilities & Assertions =====
	var DEBUG = true;
	var assert;
	if (DEBUG) {
		var AssertionError = function(message) { this.name = "AssertionError"; this.message = (message || ""); };
		AssertionError.prototype = Error.prototype;
		assert = function(condition, message) {
			if (!condition) {
				if ("assert" in console) console.assert(condition, message);
				throw new AssertionError(message);
			}
		};
	} else { assert = function(){}; }

	// ===== C escape helpers =====
	var C_ESCAPE_CHARS = "\\\"'abfnrtv?";
	var C_ESCAPE_CODES = "\\\"'\x07\b\f\n\r\t\v?";
	if (DEBUG) assert(C_ESCAPE_CODES.length === C_ESCAPE_CHARS.length, "escape tables aligned");

	function parseCString(s) {
		if (DEBUG) assert(s[0] === '"' || s[0] === '\'','C string must start with quote');
		var o = '', i = 1, b = 1, endChar = s[0];
		while (i < s.length && s[i] !== endChar && s[i] !== '\r' && s[i] !== '\n') {
			if (s[i] === '\\') {
				o += s.substring(b, i);
				var c = s[i + 1];
				i += 2;
				var index = C_ESCAPE_CHARS.indexOf(c);
				if (index >= 0) o += C_ESCAPE_CODES[index];
				else {
					b = i;
					switch (c) {
						case '\r': if (s[i] === '\n') ++i; break;
						case '\n': break;
						case 'u':
							while ("0123456789abcdefABCDEF".indexOf(s[i]) >= 0 && i < b + 4) ++i;
							if (i !== b + 4) throw new Error("Illegal C escape sequence");
							o += String.fromCharCode(parseInt(s.substring(b, i), 16));
							break;
						case 'x':
							while ("0123456789abcdefABCDEF".indexOf(s[i]) >= 0) ++i;
							if (i === b) throw new Error("Illegal C escape sequence");
							o += String.fromCharCode(parseInt(s.substring(b, i), 16));
							break;
						default:
							b = --i;
							while ("01234567".indexOf(s[i]) >= 0 && i < b + 3) ++i;
							if (i === b) throw new Error("Illegal C escape sequence");
							o += String.fromCharCode(parseInt(s.substring(b, i), 8));
							break;
					}
				}
				b = i;
			} else ++i;
		}
		if (s[i] !== endChar) throw new Error("Unterminated C string");
		return [ o + s.substring(b, i), i + 1 ];
	}

	function toHex(i, length) {
		if (DEBUG) assert(1 <= length && length <= 16, "hex len 1..16");
		var s = i.toString(16);
		return ("0000000000000000".slice(0, length - s.length) + s).slice(-length);
	}

	function escapeCString(s) {
		var o = '"', b = 0, forbid = '';
		for (var i = 0; i < s.length; ++i) {
			var c = s[i];
			var v = c.charCodeAt(0);
			if (v < 32 || v >= 127 || c === '"' || c === '\\' || forbid.indexOf(c) >= 0) {
				forbid = '';
				o += s.substring(b, i);
				var index = C_ESCAPE_CODES.indexOf(c);
				if (index >= 0) o += "\\" + C_ESCAPE_CHARS[index];
				else if (v === 0) { o += "\\0"; forbid = '01234567'; }
				else if (v <= 0xFF) { o += "\\x" + toHex(v, 2); forbid = '0123456789abcdefABCDEF'; }
				else { o += "\\u" + toHex(v, 4); }
				b = i + 1;
			} else forbid = '';
		}
		o += s.substring(b, i) + '"';
		if (DEBUG) assert(parseCString(o)[0] === s, "escape roundtrip");
		return o;
	}

	function stringListToC(strings, maxCols, pre) {
		var s = "", l = "";
		for (var i = 0; i < strings.length; ++i) {
			var w = escapeCString(strings[i]);
			if (i < strings.length - 1) w += ', ';
			if (l.length + w.length > maxCols && l !== "") { s += l + "\n" + pre; l = ""; }
			l += w;
		}
		return s + l;
	}

	var RADIX_PREFIXES = { 8: '0', 10: '', 16: '0x' };
	function numberListToC(numbers, elementsPerLine, radix, pre) {
		if (DEBUG) assert(radix === 0 || radix in RADIX_PREFIXES, "radix ok");
		var s = '';
		for (var i = 0; i < numbers.length; ++i) {
			s += (radix === 0 ? numbers[i] : RADIX_PREFIXES[radix] + numbers[i].toString(radix));
			if (i < numbers.length - 1) {
				s += ', ';
				if ((i % elementsPerLine) === elementsPerLine - 1) s += "\n" + pre;
			}
		}
		return s;
	}

	// ===== PRNG =====
	function XorshiftPRNG2x32(seed0, seed1) {
		if (typeof seed0 === "undefined") seed0 = 123456789;
		if (typeof seed1 === "undefined") seed1 = 362436069;
		var px = seed0, py = seed1;
		function next() { var t = px ^ (px << 10); px = py; py = py ^ (py >>> 13) ^ t ^ (t >>> 10); }
		this.nextInt32 = function(){ next(); return py >>> 0; };
		this.nextFloat = function(){ next(); return (py >>> 0) * 2.3283064365386962890625e-10 + (px >>> 0) * 5.42101086242752217003726400434970855712890625e-20; };
		this.nextInt = function(max){ next(); return (py >>> 0) % max; };
		this.clone = function(){ return new XorshiftPRNG2x32(px, py); };
	}
	var globalPRNG = new XorshiftPRNG2x32();
	if (!("imul" in Math)) { Math.imul = function(a,b){ var ah=(a>>>16)&0xffff, al=a&0xffff, bh=(b>>>16)&0xffff, bl=b&0xffff; return ((al*bl)+(((ah*bl+al*bh)<<16)>>>0)|0); }; }

	// ===== Eval detection =====
	var EVAL_ALLOWED = false;
	function detectEvalAllowed(){ try{ var f=eval("(function(n,w){return (n|0)+(w[0]|0);})"); return f(1,[2])===3; }catch(_){ return false; } }

	// ===== Core generator (no eval; CSP-safe) =====
	function QuickHashMaker(strings, minTableSize, maxTableSize, zeroTerminated, allowMultiplication, allowLength) {
		var stringSet = { }, maxLength = 0, minLength = 0x7fffffff;
		for (var i = 0; i < strings.length; ++i) {
			var s = strings[i];
			if (s in stringSet) throw new Error("Duplicate string: " + escapeCString(s));
			stringSet[s] = 1;
			var n = s.length; if (n < minLength) minLength = n; if (n > maxLength) maxLength = n;
		}
		var stringChars = new Array(strings.length);
		for (var i2 = 0; i2 < strings.length; ++i2) {
			var n2 = strings[i2].length, a = new Array(maxLength + 1);
			for (var j = 0; j <= maxLength; ++j) { var c = (j < n2 ? strings[i2].charCodeAt(j) : 0); if (c >= 128) c -= 256; a[j] = c; }
			stringChars[i2] = a;
		}
		var safeLength = (zeroTerminated ? minLength + 1 : minLength);

		function generateRandomExpression(rnd, complexity, constantMask, cpp, compact) {
			// Unified generator: builds a single AST that yields
                    //  - .c  : C/C++ source (p[i], guarded when i>=safeLength)
			//  - .js : JS source equivalent (w[i], Math.imul for *)
			//  - .fn : CSP-safe evaluator
			// RNG decisions are identical regardless of cpp/js to keep PRNG in sync.
			function leaf_n() { return {prec:4, c:'n', js:'n', fn:function(n,w){return n|0;}}; }
			function leaf_const() { var k=(rnd.nextInt32() & constantMask)|0; var s=String(k); return {prec:4, c:s, js:s, fn:function(){return k;}}; }
                    function leaf_w_in() { var idx=rnd.nextInt(safeLength)|0; return {prec:4, c:'p['+idx+']', js:'w['+idx+']', fn:function(n,w){ return w[idx]|0; }}; }
                    function leaf_w_out() { var span=(maxLength - safeLength)|0; var i=(rnd.nextInt(Math.max(1,span)) + safeLength)|0; return {prec:4, c:'(' + i + ' < n ? p['+i+'] : 0)', js:'w['+i+']', fn:function(n,w){ return w[i]|0; }}; }
			function needsPar(a,prec){ return (!compact || a.prec < prec); }
			function wrapC(a,prec){ return needsPar(a,prec) ? '('+a.c+')' : a.c; }
			function wrapJ(a,prec){ return needsPar(a,prec) ? '('+a.js+')' : a.js; }
			function bin(a,b,op,prec,evalFn){ return {prec:prec, c: wrapC(a,prec)+' '+op+' '+wrapC(b,prec), js: wrapJ(a,prec)+' '+op+' '+wrapJ(b,prec), fn:function(n,w){ return evalFn(a.fn(n,w), b.fn(n,w)); }}; }
                    function sh(a,dir,shamt){
                        var j = wrapJ(a,1)+' '+dir+' '+shamt;
                        var c = (dir==='<<')
                            ? '(0u + '+wrapC(a,1)+') << '+shamt
                            : wrapC(a,1)+' >> '+shamt;
                        return {prec:1, c:c, js:j, fn:function(n,w){ var v=a.fn(n,w)|0; return (dir==='<<' ? (v<<shamt) : (v>>shamt))|0; }};
                    }
			function mul(a,b){ var c = wrapC(a,3)+' * '+wrapC(b,3); var j = 'Math.imul('+a.js+', '+b.js+')'; return {prec:3, c:c, js:j, fn:function(n,w){ return Math.imul(a.fn(n,w), b.fn(n,w)); }}; }
			var OPS = [
				[ 4, 1, 1, function(){ return leaf_n(); } ],
				[ 4, 1, 1, function(){ return leaf_const(); } ],
				[ 4, 1, 1, function(){ return leaf_w_in(); } ],
				[ 4, 2, 2, function(){ return leaf_w_out(); } ],
				[ 1, 2, Infinity, function(c){ var a=rndExpr(c-1,1); var shv=(rnd.nextInt(31)+1)|0; return sh(a,'<<',shv); } ],
				[ 1, 2, Infinity, function(c){ var a=rndExpr(c-1,1); var shv=(rnd.nextInt(31)+1)|0; return sh(a,'>>',shv); } ],
				[ 2, 2, Infinity, function(c){ var b=rnd.nextInt(c-1)+1; var L=rndExpr(b,2), R=rndExpr(c-b,2); return bin(L,R,'+',2,function(x,y){return (x+y)|0;}); } ],
				[ 2, 2, Infinity, function(c){ var b=rnd.nextInt(c-1)+1; var L=rndExpr(b,2), R=rndExpr(c-b,3); return bin(L,R,'-',2,function(x,y){return (x-y)|0;}); } ],
				[ 0, 2, Infinity, function(c){ var b=rnd.nextInt(c-1)+1; var L=rndExpr(b,0), R=rndExpr(c-b,0); return bin(L,R,'^',0,function(x,y){return (x^y)|0;}); } ],
				[ 3, 2, Infinity, function(c){ var b=rnd.nextInt(c-1)+1; var L=rndExpr(b,3), R=rndExpr(c-b,3); return mul(L,R); } ],
			];
			var opFrom = (allowLength ? 0 : 1);
			var opCount = OPS.length - (allowMultiplication ? 0 : 1) - (allowLength ? 0 : 1);
			function rndExpr(c, prec){
				if (DEBUG) assert(c>0, 'c>0');
				var op; do { op = OPS[opFrom + rnd.nextInt(opCount)]; } while (c < op[1] || c > op[2]);
				var node = op[3](c);
				return node;
			}
			var root = rndExpr(complexity, 0);
			return { c: root.c, js: root.js, fn: function(n,w){ return root.fn(n,w)|0; } };
		}

		var tried = [], triedCounter = 0, counter = 0, collisions = [];
		this.search = function(complexity, iterations) {
			if (DEBUG) { assert(complexity > 0, "complexity>0"); assert((minTableSize|0)===minTableSize && (minTableSize & (minTableSize-1))===0, "minSize pow2"); assert((maxTableSize|0)===maxTableSize && (maxTableSize & (maxTableSize-1))===0, "maxSize pow2"); }
			if (!(complexity in tried)) tried[complexity] = {};
			var stringsCount = strings.length; var hashes = new Array(stringsCount);
			for (var i = 0; i < iterations; ++i) {
				var prngCopy = globalPRNG.clone();
				var exprObj = generateRandomExpression(globalPRNG, complexity, maxTableSize - 1, false, false);
				var expr = exprObj.js;
				if (complexity >= 4 || !(expr in tried[complexity])) {
					if (complexity < 4) tried[complexity][expr] = true;
					++triedCounter;
					var func;
					if (ENGINE_USE_EVAL && EVAL_ALLOWED) {
						try { func = eval("(function(n, w) { return " + expr + "; })"); }
						catch (_) {
							EVAL_ALLOWED = false; ENGINE_USE_EVAL = false;
							if (elements.forceEval) { elements.forceEval.checked = false; elements.forceEval.disabled = true; }
							updateModeLabel();
						}
					}
					if (!func) { func = exprObj.fn; }
					for (var j = 0; j < stringsCount; ++j) hashes[j] = func(strings[j].length, stringChars[j]);
					var tableSize = minTableSize, found = false;
					while (!found && tableSize <= maxTableSize) {
						var j2 = 0, hash;
						while (j2 < stringsCount && collisions[hash = (hashes[j2] & (tableSize - 1))] !== counter) { collisions[hash] = counter; ++j2; }
						counter = (counter + 1) | 0;
						if (j2 === stringsCount) found = true; else tableSize <<= 1;
					}
					if (found) {
						var table = new Array(tableSize);
						for (var j3 = 0; j3 < tableSize; ++j3) table[j3] = -1;
						for (var j4 = 0; j4 < stringsCount; ++j4) {
							var h = func(strings[j4].length, stringChars[j4]) & (tableSize - 1);
							if (DEBUG) assert(table[h] === -1, "collision unexpected");
							table[h] = j4;
						}
						return { complexity:complexity, prng:prngCopy, table:table, hashes:hashes };
					}
				}
			}
			return null;
		};

		this.getTestedCount = function(){ return triedCounter; };
		this.generateCOutput = function(template, foundSolution) {
			var cExpression = generateRandomExpression(foundSolution.prng.clone(), foundSolution.complexity, maxTableSize - 1, true, true).c;
			cExpression = '(' + cExpression + ') & ' + (foundSolution.table.length - 1);
			var replaceMap = {
				minLength: function(){ return minLength; },
				maxLength: function(){ return maxLength; },
				stringCount: function(){ return strings.length; },
				stringList: function(pre){ return stringListToC(strings, 80, pre); },
				tableSize: function(){ return foundSolution.table.length; },
				tableData: function(pre){ return numberListToC(foundSolution.table, 16, 0, pre); },
				hashExpression: function(){ return cExpression; },
				stringDescription: function(){ return zeroTerminated ? "zero terminated" : "zero termination not required"; }
			};
			var output = '', input = template;
			while (input !== '') {
				var index = input.indexOf('${'); index = (index < 0 ? input.length : index);
				output += input.substr(0, index); input = input.substr(index);
				if (input !== '') { var pre = output.substr(output.lastIndexOf("\n") + 1); index = input.indexOf('}'); index = (index < 0 ? input.length : index); output += replaceMap[input.slice(2, index)](pre); input = input.substr(index + 1); }
			}
			return output;
		};
	}

	function parseQuickHashMakerInput(text) {
		var lines = text.split("\n"), strings = [];
		for (var i = 0; i < lines.length; ++i) {
			var s = lines[i].trim(); if (!s) continue;
			if (s[0] === '"' || s[0] === '\'') {
				var o = 0; while (o < s.length) { var parsed = parseCString(s.substr(o)); strings.push(parsed[0]); o += parsed[1]; while (" \t\v\n\r".indexOf(s[o]) >= 0) ++o; if (s[o] === ',') ++o; while (" \t\v\n\r".indexOf(s[o]) >= 0) ++o; if (o < s.length && !(s[o] === '"' || s[o] === '\'')) throw new Error("Invalid input"); }
			} else strings.push(s);
		}
		return strings;
	}

	// ===== Output templates =====
        var ZERO_TERMINATED_TEMPLATE = '/* Built with http://nuedge.net/StringHashMaker */\n' +
                'static int <<findSomething>>(int n /* string length */, const char* s /* string (zero terminated) */) {\n' +
                '\tstatic const char* STRINGS[${stringCount}] = {\n' +
                '\t\t${stringList}\n' +
                '\t};\n' +
                '\tstatic const int HASH_TABLE[${tableSize}] = {\n' +
                '\t\t${tableData}\n' +
                '\t};\n' +
                '\tconst unsigned char* p = (const unsigned char*) s;\n' +
                '\tassert(s[n] == \'\\0\');\n' +
                '\tif (n < ${minLength} || n > ${maxLength}) return -1;\n' +
                '\tint stringIndex = HASH_TABLE[${hashExpression}];\n' +
                '\treturn (stringIndex >= 0 && strcmp(s, STRINGS[stringIndex]) == 0) ? stringIndex : -1;\n' +
                '}';

        var NON_ZERO_TERMINATED_TEMPLATE = '/* Built with http://nuedge.net/StringHashMaker */\n' +
                'static int <<findSomething>>(int n /* string length */, const char* s /* string (zero termination not required) */) {\n' +
                '\tstatic const char* STRINGS[${stringCount}] = {\n' +
                '\t\t${stringList}\n' +
                '\t};\n' +
                '\tstatic const int HASH_TABLE[${tableSize}] = {\n' +
                '\t\t${tableData}\n' +
                '\t};\n' +
                '\tconst unsigned char* p = (const unsigned char*) s;\n' +
                '\t// zero-termination not expected\n' +
                '\tif (n < ${minLength} || n > ${maxLength}) return -1;\n' +
                '\tint stringIndex = HASH_TABLE[${hashExpression}];\n' +
                '\treturn (stringIndex >= 0 && strncmp(s, STRINGS[stringIndex], n) == 0 && STRINGS[stringIndex][n] == 0) ? stringIndex : -1;\n' +
                '}';

	// ===== DOM wiring & state =====
	var HTML_ELEMENTS = ["editor","solutionsCount","complexity","tableSize","testedCount","requireZeroTermination","allowMultiplications","allowLength","evalTest","forceEval","hashes","startPause","testStatus"];
	var elements = {}; for (var i = 0; i < HTML_ELEMENTS.length; ++i) elements[HTML_ELEMENTS[i]] = document.getElementById(HTML_ELEMENTS[i]);

	// Pause on edits/toggles
	var isRunning = false;
	if (elements.editor) elements.editor.addEventListener('input', function(){ if (isRunning) { isRunning = false; elements.startPause.textContent = 'Start'; } });
	if (elements.allowMultiplications) elements.allowMultiplications.addEventListener('change', function(){ if (isRunning) { isRunning = false; elements.startPause.textContent = 'Start'; } });
	if (elements.allowLength) elements.allowLength.addEventListener('change', function(){ if (isRunning) { isRunning = false; elements.startPause.textContent = 'Start'; } });
	if (elements.requireZeroTermination) elements.requireZeroTermination.addEventListener('change', function(){
		currentTemplate = elements.requireZeroTermination.checked ? ZERO_TERMINATED_TEMPLATE : NON_ZERO_TERMINATED_TEMPLATE;
		// Apply signature/assert/return rewrite so the editor stays in sync with the toggle
		try {
			var code = elements.editor.value || '';
			if (code) { elements.editor.value = rewriteZeroTerminationMode(code, elements.requireZeroTermination.checked); lastInputText = elements.editor.value; }
		} catch(_) {}
		if (isRunning) { isRunning = false; elements.startPause.textContent = 'Start'; }
	});

	if (elements.forceEval) elements.forceEval.addEventListener('change', function(){ ENGINE_USE_EVAL = !!(EVAL_ALLOWED && elements.forceEval.checked); if (isRunning) { isRunning = false; elements.startPause.textContent = 'Start'; } updateModeLabel(); });

	var currentTemplate = ZERO_TERMINATED_TEMPLATE;
	var theHashMaker = null, lastInputText = elements.editor.value, solutionsCounter = 0, strings = [], minSize, maxSize, best = null;
	var ENGINE_USE_EVAL = false;

	// ===== Controls =====
	function toggleRun() {
		if (isRunning) { isRunning = false; elements.startPause.textContent = "Start"; return; }
		isRunning = true; elements.startPause.textContent = "Pause";
		resetSearch();        // re-parse editor (C++ or raw list)
		updateCodeMetadata(); // sync STRINGS length and min/max guard
	}
	window.toggleRun = toggleRun; // expose for inline onclick

	function parseStringsFromEditor(text) {
		var p = text.indexOf("STRINGS");
		if (p >= 0) {
			p = text.indexOf("{", p); if (p < 0) throw new Error("No '{' after STRINGS.");
			var i = p + 1, depth = 1, body = "";
			while (i < text.length && depth > 0) { var ch = text[i++]; if (ch === "{") depth++; else if (ch === "}") depth--; if (depth > 0) body += ch; }
			var out = [], j = 0;
			while (j < body.length) { while (j < body.length && body[j] !== '"' && body[j] !== '\'') j++; if (j >= body.length) break; var parsed = parseCString(body.slice(j)); out.push(parsed[0]); j += parsed[1]; }
			if (out.length === 0) throw new Error("Found STRINGS but no string literals.");
			return out;
		}
		return parseQuickHashMakerInput(text);
	}

	function findInitializerRange(code, declStart) {
		var eq = code.indexOf('=', declStart); if (eq < 0) return null;
		var open = code.indexOf('{', eq); if (open < 0) return null;
		var depth = 1, k = open + 1;
		while (k < code.length && depth > 0) { var ch = code[k++]; if (ch === '{') depth++; else if (ch === '}') depth--; }
		if (depth !== 0) return null;
		return { open: open, close: k - 1 };
	}

	function findMatchingSquare(code, openIndex) {
		if (openIndex < 0 || code[openIndex] !== '[') return -1;
		var depth = 0;
		for (var i = openIndex; i < code.length; ++i) {
			var ch = code[i];
			if (ch === '[') depth++;
			else if (ch === ']') { depth--; if (depth === 0) return i; }
		}
		return -1;
	}

	// ---- Eval-based verification (expression generated for C) ----
	function _baseStatusText() {
		var t = elements.testStatus.textContent || '';
		var p = t.indexOf(' | ');
		return p >= 0 ? t.slice(0, p) : t;
	}
	function updateModeLabel() {
		try {
			var base = elements.testStatus.textContent || '';
			var core = base.split(' | ')[0];
			var mode = ENGINE_USE_EVAL ? 'eval' : (EVAL_ALLOWED ? 'csp-safe (manual)' : 'csp-safe (CSP)');
			elements.testStatus.textContent = core + (core ? ' | ' : '') + 'Mode: ' + mode;
		} catch(_) {}
	}

	function verifyByEval(found) {
		if (!elements.evalTest || !elements.evalTest.checked) return; // disabled
		var expr = theHashMaker.generateCOutput("${hashExpression}", found).trim();
		var fn;
		try { fn = eval('(function(n,s){return ' + expr + ';})'); }
		catch (e) { elements.testStatus.textContent = _baseStatusText() + ' | Eval: compile error: ' + (e && e.message ? e.message : String(e)); return; }
		var minLen = Infinity; for (var i = 0; i < strings.length; ++i) { var L = strings[i].length; if (L < minLen) minLen = L; }
		if (!isFinite(minLen)) { elements.testStatus.textContent = _baseStatusText() + ' | Eval: no strings'; return; }
		var padLen = elements.requireZeroTermination.checked ? (minLen + 1) : minLen;
		var mismatches = 0, firstMsg = ''; var mod = found.table.length;
		for (var j = 0; j < strings.length; ++j) {
			var str = strings[j], n = str.length;
			var sArr = new Array(Math.max(padLen, n));
			for (var k = 0; k < sArr.length; ++k) { var c = (k < n ? str.charCodeAt(k) : 0); if (c >= 128) c -= 256; sArr[k] = c; }
			var got; try { got = fn(n, sArr); } catch (e2) { mismatches++; if (!firstMsg) firstMsg = 'runtime error on #' + j + ': ' + (e2 && e2.message ? e2.message : String(e2)); continue; }
			var idxEval = got & (mod - 1); var idxFunc = (found.hashes[j] & (mod - 1));
			if ((idxEval|0) !== (idxFunc|0) || found.table[idxEval] !== j) { mismatches++; if (!firstMsg) firstMsg = 'mismatch on #' + j + ' (' + escapeCString(str) + '): eval=' + idxEval + ', func=' + idxFunc + ', table['+idxEval+']=' + found.table[idxEval]; }
		}
		elements.testStatus.textContent = _baseStatusText() + (mismatches === 0 ? ' | Eval: OK (' + strings.length + ' checked)' : ' | Eval: ' + mismatches + ' mismatch' + (mismatches>1?'es':'') + (firstMsg?(' — ' + firstMsg):''));
	}

	// ---- Editor-line verification (checks the actual text in editor) ----
	function extractEditorHashExpr(code) {
		var useStart = code.indexOf('int stringIndex');
		var startIdx = (useStart >= 0) ? code.indexOf('HASH_TABLE[', useStart) : code.lastIndexOf('HASH_TABLE[');
		if (startIdx < 0) return null;
		var bOpen = code.indexOf('[', startIdx);
		var bClose = findMatchingSquare(code, bOpen);
		if (bOpen < 0 || bClose <= bOpen) return null;
		return code.slice(bOpen + 1, bClose);
	}
	function verifyEditorLine(found) {
		if (!elements.evalTest || !elements.evalTest.checked) return;
		var code = elements.editor.value || '';
		var expr = extractEditorHashExpr(code);
		if (!expr) { elements.testStatus.textContent = _baseStatusText() + ' | Editor: expr not found'; return; }
		var fn;
		try { fn = eval('(function(n,s){return (' + expr + ');})'); }
		catch (e) { elements.testStatus.textContent = _baseStatusText() + ' | Editor: compile error: ' + (e && e.message ? e.message : String(e)); return; }
		var minLen = Infinity; for (var i = 0; i < strings.length; ++i) { var L = strings[i].length; if (L < minLen) minLen = L; }
		if (!isFinite(minLen)) { elements.testStatus.textContent = _baseStatusText() + ' | Editor: no strings'; return; }
		var padLen = elements.requireZeroTermination.checked ? (minLen + 1) : minLen;
		var mismatches = 0, firstMsg = ''; var mod = found.table.length;
		for (var j = 0; j < strings.length; ++j) {
			var str = strings[j], n = str.length;
			var sArr = new Array(Math.max(padLen, n));
			for (var k = 0; k < sArr.length; ++k) { var c = (k < n ? str.charCodeAt(k) : 0); if (c >= 128) c -= 256; sArr[k] = c; }
			var got; try { got = fn(n, sArr); } catch (e2) { mismatches++; if (!firstMsg) firstMsg = 'runtime error on #' + j + ': ' + (e2 && e2.message ? e2.message : String(e2)); continue; }
			var idxEval = got & (mod - 1); var idxFunc = (found.hashes[j] & (mod - 1));
			if ((idxEval|0) !== (idxFunc|0) || found.table[idxEval] !== j) { mismatches++; if (!firstMsg) firstMsg = 'mismatch on #' + j + ' (' + escapeCString(str) + '): editor=' + idxEval + ', func=' + idxFunc + ', table['+idxEval+']=' + found.table[idxEval]; }
		}
		var prev = elements.testStatus.textContent || _baseStatusText();
		var left = prev.split(' | ')[0];
		elements.testStatus.textContent = left + (mismatches === 0 ? ' | Editor: OK (' + strings.length + ' checked)' : ' | Editor: ' + mismatches + ' mismatch' + (mismatches>1?'es':'') + (firstMsg?(' — ' + firstMsg):''));
	}

	function applyBestToEditor(found) {
		var code = elements.editor.value || "";
		var hasStrings = code.indexOf("STRINGS") >= 0;
		if (!hasStrings) { elements.editor.value = theHashMaker.generateCOutput(currentTemplate, found); lastInputText = elements.editor.value; return; }
		var tableSize = found.table.length;
		var tableBody = numberListToC(found.table, 16, 0, "\t\t");
		var declStart = code.indexOf("static const int HASH_TABLE[");
		if (declStart < 0) declStart = code.indexOf("HASH_TABLE[");
		if (declStart >= 0) { var declOpen = code.indexOf('[', declStart) + 1; var declClose = code.indexOf(']', declOpen); if (declOpen > 0 && declClose > declOpen) code = code.slice(0, declOpen) + String(tableSize) + code.slice(declClose); }
		var rng = findInitializerRange(code, declStart);
		if (rng) { var header = code.slice(0, rng.open + 1); var footer = code.slice(rng.close); code = header + "\n\t\t" + tableBody + "\n\t" + footer; }
		var useStart = code.indexOf("int stringIndex");
		var startIdx = (useStart >= 0) ? code.indexOf("HASH_TABLE[", useStart) : code.lastIndexOf("HASH_TABLE[");
		if (startIdx >= 0) { var bOpen = code.indexOf('[', startIdx); var bClose = findMatchingSquare(code, bOpen); if (bOpen >= 0 && bClose > bOpen) { var cExpr = theHashMaker.generateCOutput("${hashExpression}", found).trim(); code = code.slice(0, bOpen + 1) + cExpr + code.slice(bClose); } }
		elements.editor.value = code; lastInputText = elements.editor.value;
	}

	function resetSearch() {
		theHashMaker = null; solutionsCounter = 0; lastInputText = elements.editor.value; best = null;
		EVAL_ALLOWED = detectEvalAllowed();
		if (elements.forceEval) {
			if (EVAL_ALLOWED) { elements.forceEval.disabled = false; }
			else { elements.forceEval.checked = false; elements.forceEval.disabled = true; }
		}
		ENGINE_USE_EVAL = !!(EVAL_ALLOWED && elements.forceEval && elements.forceEval.checked);
		updateModeLabel();
		try { strings = parseStringsFromEditor(lastInputText); } catch (_) { strings = []; }
		if (strings.length > 0) {
			for (minSize = 1; strings.length > minSize; minSize <<= 1) ;
			maxSize = minSize * 8;
			theHashMaker = new QuickHashMaker(strings, minSize, maxSize, elements.requireZeroTermination.checked, elements.allowMultiplications.checked, elements.allowLength.checked);
			elements.hashes.innerHTML = "";
			elements.testedCount.innerHTML = "0";
			elements.solutionsCount.innerHTML = "0";
			elements.complexity.innerHTML = "?";
			elements.tableSize.innerHTML = "?";
		}
	}

	function updateCodeMetadata() {
		try {
			var code = elements.editor.value || "";
			if (code.indexOf("STRINGS") < 0) return;
			var list = (Array.isArray(strings) && strings.length) ? strings : parseStringsFromEditor(code);
			var count = list.length, minLen = Infinity, maxLen = 0;
			for (var i = 0; i < list.length; ++i) { var n = list[i].length; if (n < minLen) minLen = n; if (n > maxLen) maxLen = n; }
			if (!isFinite(minLen)) { minLen = 0; maxLen = 0; }
			var idx = code.indexOf("STRINGS["); if (idx >= 0) { idx += 8; var close = code.indexOf("]", idx); if (close >= 0) code = code.slice(0, idx) + String(count) + code.slice(close); }
			var t0 = code.indexOf("if (n < "); if (t0 >= 0) { var aStart = t0 + 8, aEnd = aStart; while (aEnd < code.length && code.charCodeAt(aEnd) >= 48 && code.charCodeAt(aEnd) <= 57) ++aEnd; var orIdx = code.indexOf("|| n > ", aEnd); if (orIdx >= 0) { var bStart = orIdx + 7, bEnd = bStart; while (bEnd < code.length && code.charCodeAt(bEnd) >= 48 && code.charCodeAt(bEnd) <= 57) ++bEnd; code = code.slice(0, aStart) + String(minLen) + code.slice(aEnd, bStart) + String(maxLen) + code.slice(bEnd); } }
			elements.editor.value = code; lastInputText = elements.editor.value;
		} catch (_) {}
	}

	function updateOutput() {
		if (best !== null) {
			try { applyBestToEditor(best); } catch (_) {}
			try { verifyByEval(best); } catch (_) {}
			try { verifyEditorLine(best); } catch (_) {}
			var s = '';
			for (var i = 0; i < strings.length; ++i) s += escapeCString(strings[i]) + ' : ' + (best.hashes[i] & (best.table.length - 1)) + ' (' + best.hashes[i] + ')\n';
			elements.hashes.innerHTML = s;
		} else elements.hashes.innerHTML = "";
	}

	function intervalFunction() {
		try {
			if (!isRunning) return;
			if (elements.editor.value !== lastInputText) resetSearch();
			if (theHashMaker !== null) {
				var timeOut = Date.now() + 100;
				while (Date.now() - timeOut < 0) {
					var complexity = globalPRNG.nextInt((best === null ? 32 : best.complexity)) + 1;
					var iters = Math.max(200 / strings.length, 1);
					var found = theHashMaker.search(complexity, iters);
					if (found !== null) {
						if (best === null || found.complexity < best.complexity || (found.complexity === best.complexity && found.table.length < best.table.length)) { best = found; updateOutput(); }
						++solutionsCounter;
					}
				}
				elements.testedCount.textContent = theHashMaker.getTestedCount();
				elements.solutionsCount.textContent = solutionsCounter;
				elements.complexity.textContent = (best === null ? "?" : best.complexity);
				elements.tableSize.textContent = (best === null ? "?" : best.table.length);
			}
		} catch (err) {
			elements.hashes.textContent = String(err);
			theHashMaker = null; isRunning = false; elements.startPause.textContent = "Start";
		}
	}
	window.setInterval(intervalFunction, 200);

	// ===== Zero-termination mode rewriter =====
	function rewriteZeroTerminationMode(code, zeroTerminated) {
		try {
			// 1) Update function arg comment
			code = code.replace(/\/\*\s*string\s*\((?:zero terminated|zero termination not required)\)\s*\*\//, zeroTerminated ? '/* string (zero terminated) */' : '/* string (zero termination not required) */');
			// 2) Toggle assert (preserve indentation and following line's tab)
                        if (zeroTerminated) {
                                code = code.replace(/\t\/\/\s*zero-termination not expected\s*\n\t\/\/\s*assert\(s\[n\]\s*==\s*'\\0'\);/m, "\tassert(s[n] == '\\0');");
                        } else {
                                code = code.replace(/\tassert\(s\[n\]\s*==\s*'\\0'\);/m, "\t// zero-termination not expected\n\t// assert(s[n] == '\\0');");
                        }
                        // 3) Switch return line
                        if (zeroTerminated) {
                                code = code.replace(/return\s*\(stringIndex\s*>=\s*0\s*&&\s*strncmp\(s,/m, "return (stringIndex >= 0 && strcmp(s, STRINGS[stringIndex]) == 0) ? stringIndex : -1;");
                        } else {
                                code = code.replace(/return\s*\(stringIndex\s*>=\s*0\s*&&\s*strcmp\(s,/m, "return (stringIndex >= 0 && strncmp(s, STRINGS[stringIndex], n) == 0 && STRINGS[stringIndex][n] == 0) ? stringIndex : -1;");
                        }
		} catch(_) {}
		return code;
	}

	// ===== Self tests =====
	function runSelfTests() {
		var ok = 0, fail = 0; function T(name, fn){ try { fn(); ok++; } catch(e){ console.error("Test fail:", name, e); fail++; } }
		T('escape/parse roundtrip', function(){ var s = "hej \n \"''\\ \x04 \u2414 \0 \r du"; var esc = escapeCString(s); var back = parseCString(esc)[0]; if (back !== s) throw new Error('roundtrip'); });
		T('parse list', function(){ var arr = parseQuickHashMakerInput('a\nb\n"c d"'); if (arr.length !== 3 || arr[2] !== 'c d') throw new Error('bad parse'); });
		T('parse from C', function(){ var code = 'static const char* STRINGS[2] = { "aa", "bb" };'; var arr = parseStringsFromEditor(code); if (arr.length !== 2 || arr[1] !== 'bb') throw new Error('bad extract'); });
		T('initializer range', function(){ var code = 'int x; static const int HASH_TABLE[4] = { 1, 2, 3, 4 };'; var ds = code.indexOf('HASH_TABLE['); var r = findInitializerRange(code, ds); if (!r || code.slice(r.open, r.close+1).indexOf('{') !== 0) throw new Error('range'); });
		T('toggleRun exists', function(){ if (typeof toggleRun !== 'function') throw new Error('missing'); if (typeof window.toggleRun !== 'function') throw new Error('not global'); });
            T('match HASH_TABLE brackets', function(){ var line = 'int stringIndex = HASH_TABLE[((p[1] + n) & 31) ^ (9 < n ? p[9] : 0)];'; var i = line.indexOf('['); var j = findMatchingSquare(line, i); if (j !== line.length - 2) throw new Error('mismatch '+j); });
            T('extract editor expr', function(){ var code = 'int stringIndex = HASH_TABLE[(n ^ p[0]) & 15];'; var expr = extractEditorHashExpr(code); if (!expr || expr.indexOf('(n ^ p[0]) & 15') < 0) throw new Error('extract failed: '+expr); });
                T('rewrite zero-term off/on', function(){
                        var code0 = 'static int f(int n, const char* s /* string (zero terminated) */) {\n\tconst unsigned char* p = (const unsigned char*) s;\n\tassert(s[n] == \'\\0\');\n\tif (n < 2) return -1;\n\tint stringIndex = 0;\n\treturn (stringIndex >= 0 && strcmp(s, STRINGS[stringIndex]) == 0) ? stringIndex : -1;\n}';
                        var off = rewriteZeroTerminationMode(code0, false);
			if (off.indexOf('zero termination not required') < 0) throw new Error('sig not switched');
			if (off.indexOf('strncmp(') < 0) throw new Error('return not switched');
			if (off.indexOf('\n\t// zero-termination not expected') < 0) throw new Error('assert not commented');
			if (off.indexOf('\n\tif (n < 2)') < 0) throw new Error('indent after assert lost');
			var on = rewriteZeroTerminationMode(off, true);
			if (on.indexOf('zero terminated') < 0) throw new Error('sig not restored');
			if (on.indexOf('strcmp(') < 0) throw new Error('return not restored');
                        if (/\tassert\(s\[n\]\s*==\s*'\\0'\)/.test(on) === false) throw new Error('assert not restored');
                });
		var msg = (fail===0? 'All tests passed ('+ok+')' : (ok+' passed, '+fail+' failed'));
		elements.testStatus.textContent = 'Self-tests: ' + msg + '.';
	}
	try { runSelfTests(); } catch(_) {}
	</script>
</body>
</html>
